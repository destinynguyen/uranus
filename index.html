<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Venus Orbit with Three.js</title>
  <style>
    /* Make the canvas fill the window */
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Proxima Nova', 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }
    canvas {
      display: block; /* removes scrollbars in some browsers */
    }

    .corner-img {
      position: fixed;
      bottom: 16px;
      left: 20vw;
      width: 120px;
      pointer-events: none;  /* lets clicks go through */
      user-select: none;
      z-index: 10000;        /* above the canvas */
    }

    /* Flexi mascot wrapper & bubble */
    .flexi-container{
      position:fixed;
      bottom:0px;
      left:50%;              /* center horizontally */
      transform:translateX(-50%);
      display:flex;
      align-items:flex-end;
      z-index:10000;
      font-family:'Proxima Nova', 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }
    .flexi-img{
      width:120px;
      pointer-events:none;
      user-select:none;
    }
    .flexi-bubble{
      margin-left:8px;
      margin-bottom: 50px;
      padding:8px 10px;
      background:rgba(255,255,255,0.9);
      color:#000;
      border-radius:8px;
      font-size:15px;
      max-width:220px;
      box-shadow:0 1px 4px rgba(0,0,0,0.3);
      display:none;
      font-family:'Proxima Nova', 'Helvetica Neue', Helvetica, Arial, sans-serif;
      position:relative;
    }

    /* triangular tail */
    .flexi-bubble::before{
      content:"";
      position:absolute;
      left:-8px;            /* protrude to left toward image */
      top:50%;              /* vertically centered */
      transform:translateY(-50%);
      width:0;
      height:0;
      border-top:8px solid transparent;
      border-bottom:8px solid transparent;
      border-right:8px solid rgba(255,255,255,0.9);
    }
  </style>
  <!-- Import map to let the browser resolve "three" and related addon paths -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
    }
  }
  </script>
  <!-- Font Awesome for icon glyphs -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />

  <style>
          /* Top menu styles */
      .menu-container {
        position: fixed;
        top: 100px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10001;
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

    .menu-list {
      margin: 0;
      padding: 0;
      list-style: none;
      display: flex;
      gap: 16px;
    }

  

          .menu-list li i {
        font-size: 26px;
        color: #fff;
        background: rgba(0, 0, 0, 0.6);
        padding: 10px;
        border-radius: 50%;
        width: 48px;
        height: 48px;
        line-height: 28px;
        cursor: pointer;
        touch-action: manipulation;
        user-select: none;
        -webkit-tap-highlight-color: rgba(0,0,0,0.1);
        transition: all 0.2s ease;
      }
      
      .menu-list li i:hover,
      .menu-list li i:active {
        background: rgba(0, 0, 0, 0.8);
      }

    .fact-box {
      position: absolute; /* float below the icons so icons stay put */
      top: 58px; /* just below 48px icon + 10px gap */
      left: 50%;
      transform: translateX(-50%);
      width: 260px;
      background: rgba(0, 0, 0, 0.75);
      color: #fff;
      padding: 8px 10px;
      border-radius: 4px;
      font-size: 13px;
      display: none;
    }

    .fact-box.show {
      display: block;
    }



    .calendar-container{
      position: absolute;
      bottom: 200px;            /* higher above icon row */
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,.65);
      padding:12px 16px;
      border-radius:8px;
      z-index:10000;
      font-family:sans-serif;
      color:#fff;
      width:320px;
      text-align:center;
    }
    .calendar-slider{
      width:100%; margin:0;
      -webkit-appearance:none; /* allow custom styling */
      appearance:none;
      height:4px;
      background:#5851FF; /* fallback for unsupported pseudo-track */
      border-radius:2px;
      cursor:pointer;
    }
    .calendar-slider::-webkit-slider-thumb{
      -webkit-appearance:none;
      appearance:none;
      width:16px; height:16px;
      border-radius:50%;
      background:#5851FF;
      cursor:pointer;
      border:none;
      box-shadow:0 0 2px rgba(0,0,0,0.4);
      margin-top:-6px; /* center thumb relative to 4px track */
    }
    .calendar-slider::-webkit-slider-runnable-track{
      height:4px;
      background:#5851FF;
      border-radius:2px;
    }
    .calendar-labels{ position:relative; font-size:12px; }
    .calendar-labels span{ position:absolute; top:4px; transform:translateX(-50%); }
    .calendar-labels span:first-child{ left:0; }
    .calendar-labels span:nth-child(2){ left:60%; }   /* label 225 */
    .calendar-labels span:last-child{ right:0; transform:none; }
    .calendar-text{ margin-bottom:6px; font-size:13px; }

    .orbit-label{
      color:#fff;
      font-size:12px;
      font-family:sans-serif;
      text-shadow:0 0 2px #000;
      pointer-events:none;
    }

    /* Mobile-specific responsive styles */
    @media (max-width: 768px) {
      /* Larger touch targets for mobile */
      .menu-list li i {
        width: 60px !important;
        height: 60px !important;
        font-size: 30px !important;
        padding: 12px !important;
        line-height: 36px !important;
      }

      /* Better text sizing for mobile */
      .flexi-bubble {
        font-size: 15px !important;
        max-width: 85vw !important;
        margin-left: 4px !important;
      }

      /* Responsive calendar container */
      .calendar-container {
        width: 85vw !important;
        max-width: 350px !important;
        padding: 16px !important;
      }

      /* Larger slider thumb for touch */
      .calendar-slider::-webkit-slider-thumb {
        width: 24px !important;
        height: 24px !important;
        margin-top: -10px !important;
      }

      /* Adjust menu positioning for mobile */
      .menu-container {
        top: 80px !important;
      }

      /* Better orbit labels for mobile */
      .orbit-label {
        font-size: 14px !important;
      }
    }

    /* Portrait orientation specific adjustments */
    @media (max-width: 768px) and (orientation: portrait) {
      .flexi-container {
        bottom: 10px !important;
      }
      
      .calendar-container {
        bottom: 180px !important;
      }
    }

    /* Landscape orientation specific adjustments */
    @media (max-width: 768px) and (orientation: landscape) {
      .menu-container {
        top: 40px !important;
      }
      
      .calendar-container {
        bottom: 120px !important;
      }
    }
  </style>
</head>
<body>
  <!-- Right-side dropdown menu -->
  <div class="menu-container">
    <ul class="menu-list">
      <li title="Surface Temperature"><i class="fa-solid fa-circle-info" data-key="fire"></i></li>
      <li title="Earth Comparison"><i class="fa-solid fa-earth-americas" data-key="earth"></i></li>
      <li title="Venus Year"><i class="fa-solid fa-calendar" data-key="calendar"></i></li>
      <li title="Restart"><i class="fa-solid fa-arrows-rotate" data-key="restart"></i></li>
    </ul>
    <div id="factBox" class="fact-box"></div>
  </div>

  <!-- We use an inline module script so the example works without any build tooling. -->
  <script type="module">
    /*
     * Import Three.js and OrbitControls directly from a CDN. This avoids the
     * need for a build step or local dependency installation.
     */
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { CSS2DRenderer, CSS2DObject } from "three/addons/renderers/CSS2DRenderer.js";

    // -------------------------------------------------------------------------
    // Mobile device detection and optimization settings
    // -------------------------------------------------------------------------
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || 
                     (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) ||
                     window.innerWidth < 768;

    // Performance settings based on device
    const performanceSettings = {
      starCount: isMobile ? 3000 : 10000,
      sphereDetail: isMobile ? 32 : 64,
      antialiasing: !isMobile // Disable antialiasing on mobile for better performance
    };

    // -------------------------------------------------------------------------
    // Basic scene setup
    // -------------------------------------------------------------------------
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 4, 6);

    const renderer = new THREE.WebGLRenderer({ antialias: performanceSettings.antialiasing });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 2 : 3));
    document.body.appendChild(renderer.domElement);

    // Label renderer for on-surface markers
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = "absolute";
    labelRenderer.domElement.style.top = "0";
    labelRenderer.domElement.style.pointerEvents = "none";
    document.body.appendChild(labelRenderer.domElement);

    // -------------------------------------------------------------------------
    // Lighting
    // -------------------------------------------------------------------------
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 3, 5);
    scene.add(directionalLight);

    // -------------------------------------------------------------------------
    // Venus sphere with texture
    // -------------------------------------------------------------------------
    const textureLoader = new THREE.TextureLoader();
    const venusTexture = textureLoader.load("./2k_uranus.jpg");

    // Preload Earth texture so Earth sphere can appear instantly when requested
    const preloadedEarthTexture = textureLoader.load("https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg");

    const sphereGeometry = new THREE.SphereGeometry(2, performanceSettings.sphereDetail, performanceSettings.sphereDetail);
    const sphereMaterial = new THREE.MeshStandardMaterial({ map: venusTexture });
    const venus = new THREE.Mesh(sphereGeometry, sphereMaterial);

    // -------------------------------------------------------------------------
    // Position Venus at the center (origin) of the scene
    // -------------------------------------------------------------------------
    venus.position.set(0, 0, 0);
    // Tilt Uranus ~98° so it appears to roll on its side
    venus.rotation.z = THREE.MathUtils.degToRad(98);
    scene.add(venus);

    // -------------------------------------------------------------------------
    // Star field background (many small points randomly distributed)
    // -------------------------------------------------------------------------
    const starGeometry = new THREE.BufferGeometry();
    const starVertices = new Float32Array(performanceSettings.starCount * 3);
    for (let i = 0; i < performanceSettings.starCount * 3; i++) {
      starVertices[i] = (Math.random() - 0.5) * 2000; // spread stars in a big cube
    }
    starGeometry.setAttribute(
      "position",
      new THREE.BufferAttribute(starVertices, 3)
    );
    const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1, sizeAttenuation: true });
    const starField = new THREE.Points(starGeometry, starMaterial);
    scene.add(starField);

    // -------------------------------------------------------------------------
    // Camera controls (optional but handy for user interaction)
    // -------------------------------------------------------------------------
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // smoother camera movement
    
    // Mobile-specific control optimizations
    if (isMobile) {
      controls.enableDamping = false; // Better touch responsiveness
      controls.rotateSpeed = 0.8; // Slightly slower rotation for touch
      controls.zoomSpeed = 1.2; // Easier pinch-to-zoom
      controls.panSpeed = 0.8; // Smooth touch panning
      controls.touches = {
        ONE: THREE.TOUCH.ROTATE,
        TWO: THREE.TOUCH.DOLLY_PAN
      };
    }

    // -------------------------------------------------------------------------
    // Earth setup (created on demand)
    // -------------------------------------------------------------------------
    let earthMesh = null;
    let rotationPaused = false;
    // Add realistic rotation rates
    const EARTH_ROT_SPEED = 0.005;   // radians per frame (~24-hour day baseline)
    const URANUS_ROT_SPEED = -EARTH_ROT_SPEED * 24 / 17; // retrograde and ~1.4× faster (~17-hour day)

    // -------------------------------------------------------------------
    // Impact experiment state (info icon)
    // -------------------------------------------------------------------
    let impactContainer = null;      // UI overlay
    let tiltAnimating = false;       // whether Uranus tilt is animating
    let tiltStartRad = 0;
    let tiltEndRad = 0;
    let tiltAnimStart = 0;

    // Impact visualization
    let impactorMesh = null;
    let impactMoving = false;
    let impactStart = 0;
    let impactDuration = 2000; // ms
    let impactStartPos = new THREE.Vector3();
    let impactTargetPos = new THREE.Vector3();
    let currentImpRadius = 0; // store active impactor size

    // Post-collision behaviours
    let impactBehavior = null;      // 'bounce' | 'debris' | 'merge'
    // Bounce parameters (small asteroid)
    let bounceMoving = false;
    let bounceStart = 0;
    let bounceDuration = 1000;
    let bounceTargetPos = new THREE.Vector3();
    // Debris field (comet cluster)
    let debrisGroup = null;
    let impactMassFactor = 0; // store selected mass value

    // Wobble (precession) state for small asteroid impacts
    let wobbleActive = false;
    let wobbleStart = 0;
    let wobbleAmp = 0; // radians

    // Axis visualization for Uranus tilt
    let axisGroup = null;
    function ensureAxis(){
      if(axisGroup) return;
      const axisLen = 5;
      axisGroup = new THREE.Group();
      // main yellow line
      const lineGeom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0,-axisLen/2,0),
        new THREE.Vector3(0, axisLen/2,0)
      ]);
      const lineMat = new THREE.LineBasicMaterial({color:0xffff00});
      axisGroup.add(new THREE.Line(lineGeom, lineMat));
      // arrow heads removed for cleaner axis visual
      // labels
      const labelStyle='color:#fff;font-size:12px;text-shadow:0 0 2px #000;';
      const nDiv=document.createElement('div');nDiv.style=labelStyle;nDiv.textContent='N';
      const sDiv=document.createElement('div');sDiv.style=labelStyle;sDiv.textContent='S';
      const nLabel=new CSS2DObject(nDiv);nLabel.position.set(0, axisLen/2 + 0.9,0);
      const sLabel=new CSS2DObject(sDiv);sLabel.position.set(0, -axisLen/2 - 0.9,0);
      axisGroup.add(nLabel);axisGroup.add(sLabel);
      venus.add(axisGroup);
    }

    // Utility to format degrees nicely
    function degString(rad){ return (THREE.MathUtils.radToDeg(rad)).toFixed(1)+"°"; }
 
    // Calendar UI elements reference
    let calendarContainer = null;

    // ---- Mini solar-system orbit (for calendar view) ----
    let orbitGroup = null;
    let miniUranus = null;
    let miniEarth = null;
    let orbitActive = false;
    let orbitDay = 0; // continuous simulated day counter

    // ---------------------------------------------
    // Uranus orbital characteristics (relative)
    // ---------------------------------------------
    const URANUS_ORBIT_R = 3.5;             // scaled-down visual radius
    const URANUS_ORBIT_DAYS = 84 * 365;     // ~84 Earth years in Earth-days

    const EARTH_ORBIT_R = 2.6;

    // Raise Venus higher so it doesn't overlap lower UI elements
    const VENUS_Y = 2;   // tweak as desired

    // Define planet visual radius constant near top of script where other consts declared
    const PLANET_RADIUS = 2; // visual radius of Uranus sphere

    // -------------------------------------------------------------------------
    // Helper for lat/lon to Vector3 on sphere
    // -------------------------------------------------------------------------
    function latLonToVector3(lat, lon, radius) {
      const latRad = (lat * Math.PI) / 180;
      const lonRad = (lon * Math.PI) / 180;
      const x = -radius * Math.cos(latRad) * Math.cos(lonRad);
      const y = radius * Math.sin(latRad);
      const z = radius * Math.cos(latRad) * Math.sin(lonRad);
      return new THREE.Vector3(x, y, z);
    }



    // -------------------------------------------------------------------------
    // Cloud layer for Venus (thick atmosphere visualization)
    // -------------------------------------------------------------------------
    let venusCloudLayer = null;
    
    function createVenusCloudLayer() {
      return; // Disabled: Uranus has no thick yellow cloud layer
      if (venusCloudLayer) return; // already created
      
      // Scale down Venus for better view of cloud effect
      venus.scale.set(0.7, 0.7, 0.7);
      
      // Create a slightly larger sphere to represent the thick atmosphere
      const cloudGeometry = new THREE.SphereGeometry(1.8, performanceSettings.sphereDetail, performanceSettings.sphereDetail);
      const cloudMaterial = new THREE.MeshBasicMaterial({
        color: 0xffd700, // yellowish color for sulfuric acid clouds
        transparent: true,
        opacity: 0.4,
        side: THREE.DoubleSide
      });
      
      venusCloudLayer = new THREE.Mesh(cloudGeometry, cloudMaterial);
      venusCloudLayer.position.copy(venus.position);
      scene.add(venusCloudLayer);
    }
    
    function removeVenusCloudLayer() {
      if (venusCloudLayer) {
        scene.remove(venusCloudLayer);
        venusCloudLayer.geometry.dispose();
        venusCloudLayer.material.dispose();
        venusCloudLayer = null;
        
        // Restore Venus to original size
        venus.scale.set(1, 1, 1);
      }
    }

    // -------------------------------------------------------------
    // Impact experiment UI and logic
    // -------------------------------------------------------------
    function createImpactExperiment(){
      if(impactContainer) return;

      // Inject styles once
      if(!document.getElementById('impactStyles')){
        const styleTag=document.createElement('style');
        styleTag.id='impactStyles';
        styleTag.textContent=`
        .impact-container{width:260px;background:rgba(20,20,30,.8);backdrop-filter:blur(4px);border:1px solid rgba(255,255,255,.15);box-shadow:0 4px 10px rgba(0,0,0,.5);border-radius:10px;font-family:'Proxima Nova','Helvetica Neue',Helvetica,Arial,sans-serif;color:#fff;}
        .impact-container .impact-title{font-size:16px;font-weight:600;margin-bottom:8px;text-align:center;}
        .impact-container label{display:block;font-size:13px;margin-top:8px;margin-bottom:2px;}
        .impact-container select,.impact-container input[type=range]{width:100%;}
        .impact-container input[type=range]{margin-top:2px;}
        .impact-container button{width:100%;padding:6px 0;margin-top:10px;border:none;border-radius:6px;background:#5851FF;color:#fff;font-size:14px;cursor:pointer;transition:background .2s;}
        .impact-container button:hover{background:#6a63ff;}
        .impact-container .tilt-display{margin-top:10px;font-size:13px;text-align:center;}
        .impact-container button.secondary{background:#444;border:1px solid #666;margin-top:6px;}
        .impact-container button.secondary:hover{background:#555;}
        `;
        document.head.appendChild(styleTag);
      }
      ensureAxis();

      impactContainer = document.createElement('div');
      impactContainer.className = 'impact-container';
      impactContainer.style.position = 'absolute';
      impactContainer.style.top = '50%';
      impactContainer.style.left = '140px';
      impactContainer.style.transform = 'translateY(-50%)';
      impactContainer.style.background = 'rgba(0,0,0,0.6)';
      impactContainer.style.color = '#fff';
      impactContainer.style.padding = '12px';
      impactContainer.style.borderRadius = '8px';
      impactContainer.style.fontSize = '14px';
      impactContainer.style.zIndex = '10';

      impactContainer.innerHTML = `
        <div class="impact-title">Experiment: Giant Impact</div>
        <label>Impactor:</label>
        <select id="impSel">
          <option value="1">Small asteroid</option>
          <option value="5">Comet cluster</option>
          <option value="15">Mars-sized planet</option>
          <option value="30">Icy giant</option>
        </select>
        <label>Impact speed (km/s)</label>
        <input type="range" id="spd" min="5" max="30" value="15"/> <span id="spdVal">15</span>
        <label>Impact angle (°)</label>
        <input type="range" id="ang" min="0" max="90" value="45"/> <span id="angVal">45</span>
        <button id="impactBtn">Impact!</button>
        <div class="tilt-display">Axial tilt: <span id="tiltVal">`+degString(venus.rotation.z)+`</span></div>
      `;

      document.body.appendChild(impactContainer);

      const spd = impactContainer.querySelector('#spd');
      const ang = impactContainer.querySelector('#ang');
      spd.addEventListener('input', ()=> impactContainer.querySelector('#spdVal').textContent = spd.value);
      ang.addEventListener('input', ()=> impactContainer.querySelector('#angVal').textContent = ang.value);

      // Button will toggle between "Impact!" and "Restart"
      impactContainer.querySelector('#impactBtn').addEventListener('click', (e)=>{
        const impactBtn = e.currentTarget;
        if(impactBtn.dataset.mode === 'restart'){
          removeImpactExperiment();
          createImpactExperiment();
          return;
        }
        const massFactor = parseFloat(impactContainer.querySelector('#impSel').value);
        const speed = parseFloat(spd.value);
        const angleDeg = parseFloat(ang.value);

        impactMassFactor = massFactor; // keep for later physics outcome

        // Decide behaviour based on impactor type
        if(massFactor === 1){
          impactBehavior = 'bounce';            // small asteroid
        }else if(massFactor === 5 || massFactor === 30){
          impactBehavior = 'debris';            // comet cluster or icy giant break apart
        }else{ // 15
          impactBehavior = 'merge';             // Mars-sized planet merges
        }

        // Simple heuristic for tilt change
        const currentTiltDeg = THREE.MathUtils.radToDeg(venus.rotation.z);
        let deltaTiltDeg = Math.min(60, massFactor * (speed/30) * (angleDeg/90) * 20);
        if(massFactor===1){
          deltaTiltDeg = Math.min(deltaTiltDeg, 5); // asteroid <=5°
        }
        if(massFactor===5){
          deltaTiltDeg = Math.max(20, Math.min(deltaTiltDeg, 40)); // comet cluster modest 20–40°
        } else if(massFactor===15){
          // Mars-sized impact pushes toward 98° total tilt
          deltaTiltDeg = Math.max(0, 98 - currentTiltDeg);
        }
        const newTiltDeg = Math.min(180, currentTiltDeg + deltaTiltDeg);

        tiltStartRad = venus.rotation.z;
        tiltEndRad = THREE.MathUtils.degToRad(newTiltDeg);
        tiltAnimStart = performance.now();
        tiltAnimating = true;

        // -----------------------------
        // Create visual impactor
        // -----------------------------
        if(impactorMesh){ // remove old one
          scene.remove(impactorMesh);
          impactorMesh.geometry.dispose();
          impactorMesh.material.dispose();
          impactorMesh = null;
        }

        // radius mapping (rough)
        let impRadius = 0.15; // default asteroid
        if(massFactor>=30) impRadius = 1.0; // icy giant
        else if(massFactor>=15) impRadius = 0.8; // mars-sized larger for visibility
        else if(massFactor>=5) impRadius = 0.3; // comet cluster

        // Update color map
        const colors = {
          1: 0x888888,   // asteroid gray
          5: 0xffffff,   // comet icy white
          15: 0xff5533,  // Mars-sized: bright reddish
          30: 0x66ccff   // icy giant blue
        };
        const colorHex = colors[massFactor] || 0x888888;

        const impGeom = new THREE.SphereGeometry(impRadius, 16, 16);
        const impMat = new THREE.MeshStandardMaterial({color: colorHex});
        impactorMesh = new THREE.Mesh(impGeom, impMat);

        // Start position far along +X direction relative to Uranus
        if(massFactor===15){
          impactStartPos.set(4, 1.5, 4); // Inside camera frustum front-right
        }else{
          impactStartPos.set(10, 0, 0);
        }
        impactTargetPos.copy(venus.position);
        impactorMesh.position.copy(impactStartPos);
        scene.add(impactorMesh);

        currentImpRadius = impRadius; // store for collision distance check

        impactStart = performance.now();
        impactMoving = true;
        bounceMoving = false;

        if(impactBehavior==='bounce'){
          wobbleActive = true;
          wobbleStart = performance.now();
          wobbleAmp = THREE.MathUtils.degToRad(2); // 2° wiggle
        } else if(massFactor===5){
          wobbleActive = true;
          wobbleStart = performance.now();
          wobbleAmp = THREE.MathUtils.degToRad(4); // 4° wobble for comet cluster
        } else if(massFactor===15){
          wobbleActive = true;
          wobbleStart = performance.now();
          wobbleAmp = THREE.MathUtils.degToRad(6); // stronger wobble for Mars-sized impact
        }
        impactBtn.dataset.mode = 'restart';
        impactBtn.textContent = 'Restart';
        impactBtn.classList.add('secondary');
      });
    }

    function removeImpactExperiment(){
      if(impactContainer){
        impactContainer.remove();
        impactContainer = null;
      }
      // Clean debris and impactor
      if(debrisGroup){
        debrisGroup.traverse(obj=>{ if(obj.geometry) obj.geometry.dispose(); if(obj.material) obj.material.dispose(); });
        scene.remove(debrisGroup);
        debrisGroup = null;
      }
      if(impactorMesh){
        scene.remove(impactorMesh);
        impactorMesh.geometry.dispose();
        impactorMesh.material.dispose();
        impactorMesh = null;
      }
      if(axisGroup){
        axisGroup.traverse(obj=>{
          if(obj instanceof CSS2DObject){
            if(obj.element && obj.element.parentNode){
              obj.element.parentNode.removeChild(obj.element);
            }
          }
          if(obj.geometry) obj.geometry.dispose();
          if(obj.material) obj.material.dispose();
        });
        venus.remove(axisGroup);
        axisGroup = null;
      }
      impactMoving = bounceMoving = false;
    }

    // -------------------------------------------------------------------------
    // Earth creation (first Earth-icon click)
    // -------------------------------------------------------------------------
    function createEarth() {
      if (earthMesh) return;

      // Shift Venus left first so positions are set before rendering
      venus.position.set(-2.5, 0, 0);

      const earthGeom = new THREE.SphereGeometry(0.5, performanceSettings.sphereDetail, performanceSettings.sphereDetail);
      const earthMat = new THREE.MeshStandardMaterial({ map: preloadedEarthTexture });
      earthMesh = new THREE.Mesh(earthGeom, earthMat);
      earthMesh.position.set(2.5, 0, 0);
      scene.add(earthMesh);
    }

    function removeEarth() {
      if (earthMesh) {
        scene.remove(earthMesh);
        earthMesh.geometry.dispose();
        earthMesh.material.dispose();
        earthMesh = null;
      }
    }

    // -------------------------------------------------------------------------
    // Calendar slider UI
    // -------------------------------------------------------------------------
    function createCalendarUI() {
      if (calendarContainer) return;

      calendarContainer = document.createElement("div");
      calendarContainer.className = "calendar-container";

      calendarContainer.innerHTML = `
        <div class="calendar-text">Explore Uranus&#39;s 84-year orbit (0 – 30 660 Earth days)</div>
        <input type="range" min="0" max="30660" value="0" class="calendar-slider" id="daySlider" />
        <div class="calendar-labels">
          <span>0</span>
          <span style="left: 50%">15 330</span>
          <span style="right: 0">30 660</span>
        </div>
      `;

      document.body.appendChild(calendarContainer);

      const sliderEl = calendarContainer.querySelector('#daySlider');
      sliderEl.addEventListener('input', (e)=>{
        const val = parseInt(sliderEl.value,10);
        setOrbitDay(val);
      });

      createOrbitSystem();
      setOrbitDay(0);
    }

    function removeCalendarUI() {
      if (calendarContainer) {
        calendarContainer.remove();
        calendarContainer = null;
      }

      removeOrbitSystem();

      // Return planets to original height
      venus.position.y = 0;
      if (earthMesh) earthMesh.position.y = 0;

      // Restore big Venus/Earth visibility
      venus.visible = true;
      if (earthMesh) earthMesh.visible = true;
    }

    function resetState(selectedKey) {
      // Remove Earth if not selecting earth
      if (selectedKey !== 'earth') {
        removeEarth();
        // center Venus if it was shifted
        venus.position.set(0, 0, 0);
      }

      // Remove cloud layer if not selecting fire/info
      if (selectedKey !== 'fire') {
        removeVenusCloudLayer();
        removeImpactExperiment();
      }

      // Remove calendar UI if not selecting calendar
      if (selectedKey !== 'calendar') {
        removeCalendarUI();
      }
    }

    // ---------------------------------------------------------------------
    // Restart helper – restores scene to initial state without page reload
    // ---------------------------------------------------------------------
    function restartScene(){
      // Remove any dynamic elements
      removeEarth();
      removeVenusCloudLayer();
      removeCalendarUI();
      removeImpactExperiment();

      // Reset Venus
      venus.position.set(0,0,0);
      venus.visible = true;
      rotationPaused = false;
      
      // Re-enable camera controls
      controls.enabled = true;

      // Reset Flexi message
      flexiBubbleElem.textContent = "Click an icon to learn more about Uranus!";
      factBoxElem.classList.remove('show');
    }

    // -------------------------------------------------------------------------
    // Facts and menu interactivity
    // -------------------------------------------------------------------------
    const facts = {
      fire: "A colossal collision early in Uranus’s history likely smashed the planet onto its side—leaving it with a 98° axial tilt while barely changing its frigid atmosphere.",
      rotation: "Rotation: Uranus completes a day in about 17 Earth hours and spins retrograde (opposite to most planets) on its tilted axis.",
      calendar: "Orbital period: Uranus takes about 84 Earth years (≈30,660 Earth days) to orbit the Sun.",
      earth: "Size comparison: Uranus has a radius of roughly 25,362 km—about four times Earth's diameter—making it an ice giant."
    };

    const factBoxElem = document.getElementById("factBox");
    const flexiBubbleElem = document.getElementById("flexiBubble");

    // Default message before any icon is clicked
    flexiBubbleElem.textContent = "Click an icon to learn more about Uranus!";
    flexiBubbleElem.style.display = 'block';

    document.querySelectorAll('.menu-list i[data-key]').forEach((icon) => {
      icon.style.cursor = 'pointer';
      icon.addEventListener('click', () => {
        const key = icon.dataset.key;
        // Update Flexi bubble and ensure it's visible
        flexiBubbleElem.textContent = facts[key] ?? '';
        flexiBubbleElem.style.display = 'block';

        // Ensure the centered fact box stays hidden
        factBoxElem.classList.remove('show');

        resetState(key);

        if (key === 'restart') {
          restartScene();
          return;
        } else if (key === 'earth') {
          createEarth();
        } else if (key === 'fire') {
          createImpactExperiment();
        } else if (key === 'calendar') {
          createCalendarUI();
        }
      });
    });

    // -------------------------------------------------------------------------
    // Animation loop
    // -------------------------------------------------------------------------
    function animate() {
      requestAnimationFrame(animate);

      // Uranus retrograde rotation (~17-hour day)
      if (!rotationPaused) {
        venus.rotation.y += URANUS_ROT_SPEED;
      }

      // Cloud layer rotation - slightly different speed to create atmospheric effect
      if (venusCloudLayer) {
        venusCloudLayer.rotation.y += 0.01; // faster rotation for dynamic cloud effect
        venusCloudLayer.position.copy(venus.position); // follow Venus position
      }

      // Earth prograde rotation (~24-hour day)
      if (earthMesh) earthMesh.rotation.y += EARTH_ROT_SPEED;

      // Mini orbits now advance only via the slider; no automatic update.

      if (controls.enabled) {
        controls.update();
      }
      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);

      // Tilt animation after impact
      if(tiltAnimating){
        const t = (performance.now() - tiltAnimStart)/2000; // 2-second anim
        if(t>=1){
          venus.rotation.z = tiltEndRad;
          tiltAnimating = false;
        }else{
          venus.rotation.z = THREE.MathUtils.lerp(tiltStartRad, tiltEndRad, t);
        }
        // update UI value if present
        if(impactContainer){
          const tv = impactContainer.querySelector('#tiltVal');
          if(tv) tv.textContent = degString(venus.rotation.z);
        }
      }

      // Post-impact wobble for small asteroid
      if(wobbleActive && !tiltAnimating){
        const tW = performance.now() - wobbleStart;
        const decay = Math.exp(-tW/4000); // 4-s decay
        const wobbleAngle = wobbleAmp * decay * Math.sin(tW*0.01);
        venus.rotation.z = tiltEndRad + wobbleAngle;
        if(decay < 0.02){
          wobbleActive = false;
          venus.rotation.z = tiltEndRad; // settle
        }
      }

      // Move impactor towards Uranus
      if(impactMoving && impactorMesh){
        // Update position along path
        const elapsed = (performance.now() - impactStart);
        const t = Math.min(1, elapsed / impactDuration);
        impactorMesh.position.lerpVectors(impactStartPos, impactTargetPos, t);

        const distToCenter = impactorMesh.position.distanceTo(impactTargetPos);
        const contactDist = PLANET_RADIUS + currentImpRadius;
        if(distToCenter <= contactDist || t>=1){

          // Handle physics outcome
          if(impactBehavior === 'bounce'){
            // Prepare outward bounce proportional to speed
            const dir = new THREE.Vector3().subVectors(impactStartPos, impactTargetPos).normalize();
            const speedVal = parseFloat(impactContainer ? impactContainer.querySelector('#spd').value : 15);
            const dist = 2 + (speedVal/30)*6;
            bounceTargetPos.copy(impactTargetPos).addScaledVector(dir, dist);
            bounceDuration = 500 + (dist/8)*1000;
            bounceStart = performance.now();
            bounceMoving = true;
          }else if(impactBehavior === 'debris'){
            // Create debris field
            if(debrisGroup) scene.remove(debrisGroup);
            debrisGroup = new THREE.Group();
            const debrisCount = (impactMassFactor===30)? 300 : 100;

            if(impactMassFactor===30){
              // Spherical debris cloud approximating former icy giant
              const cloudR = currentImpRadius * 1.2;
              for(let i=0;i<debrisCount;i++){
                // random point in sphere using spherical coordinates
                const u = Math.random();
                const v = Math.random();
                const theta = 2 * Math.PI * u;
                const phi = Math.acos(2*v - 1);
                const rRand = cloudR * Math.cbrt(Math.random());
                const x = rRand * Math.sin(phi) * Math.cos(theta);
                const y = rRand * Math.sin(phi) * Math.sin(theta);
                const z = rRand * Math.cos(phi);

                const dGeom = new THREE.SphereGeometry(0.025, 8, 8);
                const dMat = new THREE.MeshBasicMaterial({color:0x99ccff});
                const piece = new THREE.Mesh(dGeom, dMat);
                piece.position.set(x, y, z);
                // store outward velocity for simple expansion
                piece.userData.vel = new THREE.Vector3(x,y,z).normalize().multiplyScalar(0.02 + 0.04*Math.random());
                debrisGroup.add(piece);
              }
              debrisGroup.userData.type = 'sphere';
            }else{
              // Ring debris (comet cluster case)
              const ringR = 2.5;
              for(let i=0;i<debrisCount;i++){
                const theta = Math.random()*Math.PI*2;
                const yOff = (Math.random()-0.5)*0.2;
                const dGeom = new THREE.SphereGeometry(0.02,8,8);
                const dMat = new THREE.MeshBasicMaterial({color:0x99ccff});
                const piece = new THREE.Mesh(dGeom,dMat);
                piece.position.set(Math.cos(theta)*ringR, yOff, Math.sin(theta)*ringR);
                debrisGroup.add(piece);
              }
              debrisGroup.userData.type = 'ring';
            }

            debrisGroup.position.copy(impactorMesh.position);
            scene.add(debrisGroup);

            // remove impactor
            scene.remove(impactorMesh);
            impactorMesh.geometry.dispose();
            impactorMesh.material.dispose();
            impactorMesh = null;
          }else{ // merge
            // Simple merge: enlarge Uranus slightly proportional to massFactor
            const scaleUp = 1 + impactMassFactor*0.01; // small visual bump
            venus.scale.set(scaleUp, scaleUp, scaleUp);
            // remove impactor mesh
            scene.remove(impactorMesh);
            impactorMesh.geometry.dispose();
            impactorMesh.material.dispose();
            impactorMesh = null;
          }

          impactMoving = false;
        }else{
          impactorMesh.position.lerpVectors(impactStartPos, impactTargetPos, t);
        }
      }

      // Bounce outward animation
      if(bounceMoving && impactorMesh){
        const tB = (performance.now() - bounceStart)/bounceDuration;
        if(tB>=1){
          scene.remove(impactorMesh);
          impactorMesh.geometry.dispose();
          impactorMesh.material.dispose();
          impactorMesh = null;
          bounceMoving = false;
        }else{
          impactorMesh.position.lerpVectors(impactTargetPos, bounceTargetPos, tB);
        }
      }

      // Debris animation
      if(debrisGroup){
        if(debrisGroup.userData.type === 'ring'){
          debrisGroup.rotation.y += 0.002; // rotate ring
        }else if(debrisGroup.userData.type === 'sphere'){
          // expand cloud pieces outward
          debrisGroup.children.forEach((piece)=>{
            if(piece.userData && piece.userData.vel){
              piece.position.add(piece.userData.vel);
              // optional fade out or slow down; skipped for simplicity
            }
          });
        }
      }
    }
    animate();

    // -------------------------------------------------------------------------
    // Responsive resizing
    // -------------------------------------------------------------------------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
    });

    // -------------------------------------------------------------------------
    // Mini solar-system orbit (for calendar view)
    // -------------------------------------------------------------------------
    function createOrbitSystem() {
      if (orbitGroup) return;

      orbitGroup = new THREE.Group();
      orbitGroup.position.set(0, 1, 0); // lift mini solar system upward
      scene.add(orbitGroup);

      // Sun
      const sunTexture = textureLoader.load("./2k_sun.jpg");
      const sunMesh = new THREE.Mesh(
        new THREE.SphereGeometry(0.18, Math.max(16, performanceSettings.sphereDetail / 2), Math.max(16, performanceSettings.sphereDetail / 2)),
        new THREE.MeshBasicMaterial({ map: sunTexture })
      );
      orbitGroup.add(sunMesh);

      // Orbit rings
      const makeRing = (r) => {
        const seg = 128;
        const pts = [];
        for (let i = 0; i <= seg; i++) {
          const a = (i / seg) * Math.PI * 2;
          pts.push(new THREE.Vector3(Math.cos(a) * r, 0, Math.sin(a) * r));
        }
        const geom = new THREE.BufferGeometry().setFromPoints(pts);
        const mat = new THREE.LineBasicMaterial({ color: 0x888888 });
        return new THREE.Line(geom, mat);
      };
      orbitGroup.add(makeRing(URANUS_ORBIT_R));
      orbitGroup.add(makeRing(EARTH_ORBIT_R));

      const uranusTexMini = textureLoader.load("./2k_uranus.jpg");
      const earthTexMini = textureLoader.load("https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg");

      // Mini Uranus
      miniUranus = new THREE.Mesh(
        new THREE.SphereGeometry(0.44, Math.max(16, performanceSettings.sphereDetail / 2), Math.max(16, performanceSettings.sphereDetail / 2)),
        new THREE.MeshStandardMaterial({ map: uranusTexMini })
      );
      miniUranus.rotation.z = THREE.MathUtils.degToRad(98); // axial tilt
      orbitGroup.add(miniUranus);

      // Mini Earth
      miniEarth = new THREE.Mesh(
        new THREE.SphereGeometry(0.11, Math.max(16, performanceSettings.sphereDetail / 2), Math.max(16, performanceSettings.sphereDetail / 2)),
        new THREE.MeshBasicMaterial({ map: earthTexMini })
      );
      orbitGroup.add(miniEarth);

      // Labels
      const vDiv = document.createElement('div');
      vDiv.className = 'orbit-label';
      vDiv.textContent = 'Uranus';
      const vLabel = new CSS2DObject(vDiv);
      vLabel.position.set(0, 0.55, 0);
      miniUranus.add(vLabel);

      const eDiv = document.createElement('div');
      eDiv.className = 'orbit-label';
      eDiv.textContent = 'Earth';
      const eLabel = new CSS2DObject(eDiv);
      eLabel.position.set(0, 0.25, 0);
      miniEarth.add(eLabel);

      orbitActive = true;

      // Hide big planets
      venus.visible = false;
      if (earthMesh) earthMesh.visible = false;
    }

    function removeOrbitSystem() {
      if (!orbitGroup) return;
      // Remove DOM elements of CSS2DObjects and dispose geometries/materials
      orbitGroup.traverse((obj) => {
        if (obj instanceof CSS2DObject) {
          if (obj.element && obj.element.parentNode) {
            obj.element.parentNode.removeChild(obj.element);
          }
        }
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) obj.material.dispose();
      });
      scene.remove(orbitGroup);
      orbitGroup = null;
      miniUranus = miniEarth = null;
      orbitActive = false;

      // Show big planets back
      venus.visible = true;
      if (earthMesh) earthMesh.visible = true;
    }

    function updateMiniOrbits(deltaDays) {
      if (!orbitActive) return;

      orbitDay += deltaDays;

      const thetaU = ((orbitDay % URANUS_ORBIT_DAYS) / URANUS_ORBIT_DAYS) * Math.PI * 2; // wrap by Uranus period
      const thetaE = ((orbitDay % 365) / 365) * Math.PI * 2;

      miniUranus.position.set(Math.cos(thetaU) * URANUS_ORBIT_R, 0, Math.sin(thetaU) * URANUS_ORBIT_R);
      miniEarth.position.set(Math.cos(thetaE) * EARTH_ORBIT_R, 0, Math.sin(thetaE) * EARTH_ORBIT_R);
    }

    // Set orbit day directly (used by slider)
    function setOrbitDay(dayVal){
      orbitDay = dayVal;
      const thetaU = ((orbitDay % URANUS_ORBIT_DAYS) / URANUS_ORBIT_DAYS) * Math.PI * 2;
      const thetaE = ((orbitDay % 365) / 365) * Math.PI * 2;
      if(miniUranus&&miniEarth){
        miniUranus.position.set(Math.cos(thetaU)*URANUS_ORBIT_R,0,Math.sin(thetaU)*URANUS_ORBIT_R);
        miniEarth.position.set(Math.cos(thetaE)*EARTH_ORBIT_R,0,Math.sin(thetaE)*EARTH_ORBIT_R);
      }
    }
  </script>

  <!-- No extra JS needed; interactivity handled in module script -->

  <!--
    NOTE: If you open this file directly from the filesystem (file://), you may
    run into CORS issues loading the texture. It's recommended to serve the
    folder via a simple local web server. For example, from the terminal:

      python3 -m http.server 8000

    Then visit http://localhost:8000 in your browser.
  -->
  <div class="flexi-container">
    <img src="./Flexi_Telescope.svg" alt="Flexi with telescope" class="flexi-img" />
    <div id="flexiBubble" class="flexi-bubble"></div>
  </div>
</body>
</html>